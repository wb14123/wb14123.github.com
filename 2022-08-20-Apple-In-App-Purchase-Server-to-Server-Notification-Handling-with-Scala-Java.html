<!DOCTYPE html>

<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title> Handle Apple In-App-Purchase Server Notification with Scala/Java |  Bin Wang - My Personal Blog</title>
    <link rel="stylesheet" href="/static/css/default.css" type="text/css" />

		<!--
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-52904500-1', 'auto');
      ga('send', 'pageview');
    </script>
		-->

		<!-- Matomo -->
		<script>
		  var _paq = window._paq = window._paq || [];
		  /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
		  _paq.push(['trackPageView']);
		  _paq.push(['enableLinkTracking']);
		  (function() {
		    var u="//matomo.rssbrain.com/";
		    _paq.push(['setTrackerUrl', u+'matomo.php']);
		    _paq.push(['setSiteId', '2']);
		    var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
		    g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
		  })();
		</script>
		<!-- End Matomo Code -->


  </head>

  <body>
    <header id="page_header">
      <nav id="page_nav">
        <ul>
             <li><a href="/">Home</a></li>
             <li><a href="/index_page.html">Index</a></li>
             <li><a href="/snippets">Snippets</a></li>
             <li><a href="https://www.goodreads.com/review/list/103708630-bin?shelf=read" target="_blank">Read</a></li>
             <li><a href="/travel.html">Travel</a></li>
             <li><a href="/search.html">Search</a></li>
             <li><a href="/about.html">About</a></li>
             <li><a href="/feed.xml">RSS</a></li>
       </ul>
      </nav>

    </header>

    <section id="page_content">
      <div id="content_table">
  <h3>Table of Contents</h3><ol class="toc"><li><a href="#1-how-to-trigger-a-server-notification">1. How to Trigger a Server Notification</a></li><li><a href="#2-server-notification-workflow">2. Server Notification Workflow</a></li><li><a href="#4-decode-and-verify-notification">4. Decode and Verify Notification</a></li><li><a href="#5-other-thoughts">5. Other Thoughts</a></li></ol>
</div>

<div id="article_content" class="">
<article id="post">
  <header>
    <h1>Handle Apple In-App-Purchase Server Notification with Scala/Java</h1>
    
      <p class="description">Posted on 20 Aug 2022, tagged <code>iOS</code><code>Apple</code><code>In App Purchase</code><code>Scala</code><code>Java</code><code>Programming</code></p>
    
  </header>

  <p>When you write an app for iOS, publish it to Apple App Store and want to sell something within it, Apple makes it mandatory to use its own in app purchase framework for non consumable items and subscriptions. If the app has a server, it’s very usual that the server wants to know the payment events and have some followup logic with them. But how to do that? There is always an option to let the app send a request to server, but anyone can use the same endpoint to make false claims. To prevent this, Apple has a server to server notification mechanism: Instead the app itself, a server from Apple will send a request to your server to notify the payment events. Since the message is signed by Apple, you can make sure no one else can fake it by verifying the signature.</p>

<p>While this framework should in theory makes developer’s life easier, the lack of documentation makes it very painful to use. There is also little and often wrong information on the Internet about how to verify the signature, especially for a server written with Java related tech stack. So in this article, I will give an example about how to decode and verify the payment notification messages sent by Apple with Scala. The library we are using is <a href="https://connect2id.com/products/nimbus-jose-jwt">Nimbus JOSE + JWT</a> which is written in Java, so the method applies to other JVM languages as well. Hopefully this can help other developers who are facing the same problem.</p>

<h2 id="1-how-to-trigger-a-server-notification">1. How to Trigger a Server Notification</h2>

<p>Needless to say, to receive a payment notification you must initiate a payment from the app. There are various ways to do it and we will not discuss it in this article. But be aware there are two ways to test the in app payment: create a <a href="https://developer.apple.com/documentation/xcode/setting-up-storekit-testing-in-xcode">StoreKit configuration in Xcode</a> or <a href="https://developer.apple.com/documentation/storekit/in-app_purchase/testing_in-app_purchases_with_sandbox">use a sandbox environment</a>. Only the later one will trigger a server to server notification.</p>

<p>Another requirement is to set up the notification endpoint in Apple Connection settings. The endpoint is a https URL that Apple will send a http post request to. <a href="https://developer.apple.com/documentation/storekit/in-app_purchase/original_api_for_in-app_purchase/subscriptions_and_offers/enabling_app_store_server_notifications">Here</a> is the Apple document about how to do it.</p>

<h2 id="2-server-notification-workflow">2. Server Notification Workflow</h2>

<p>In order to better understand how to handle the notification message, let’s take a look at the server notification workflow first.</p>

<p><img src="/static/images/2022-08-20-Apple-In-App-Purchase-Server-to-Server-Notification-Handling-with-Scala-Java/iap-server-notification.png" alt="iap-server-notification" /></p>

<p>When Apple receives some payment information, whether it’s from the app, or from subscription renew, or subscription expiration or other events, it will try to send the event to your server by sending an http POST request. In order to make sure no other people can fake a request to the same http endpoint, Apple signs the request payload with a private key that only Apple has access, so that when your server received the message, you can verify it by Apple’s public key.</p>

<p>The way Apple signs the message is using a standard called <a href="https://www.rfc-editor.org/rfc/rfc7515.html">JWS</a>. This is a complex standard with multiple implementation options. To fully understand it you also need to know things like <a href="https://www.rfc-editor.org/rfc/rfc7518.html">JWA</a> and <a href="https://www.rfc-editor.org/rfc/rfc7517">JWK</a>. Apple has very little document about how to decode its own message other than throw this RFC page into the document. Even in support forums, their response is like “use your favourite crypto library”, which doesn’t really help anything.</p>

<h3 id="3-jws-overview">3. JWS Overview</h3>

<p>To make it easy, I will give a very simple overview of JWS, JWS has three parts: a header that contains metadata like keys and algorithm to use, the actual payload, and a signature:</p>

<div class="language-plaintext highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>header (metadata)
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>-----------
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>payload (actual message we want, base64 encoded JSON)
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>-----------
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>signature (generated by applying crypto algrithm on payload with keys in header)
</pre></div>
</div>
</div>

<p>So in order to make sure the whole message is actually sent by Apple, we need to verify:</p>

<ul>
  <li>The signature is generated by the keys in header and the payload.</li>
  <li>The keys in header is generated by Apple.</li>
</ul>

<p>Since the payload is only base64 encoded, for a developer that is not familiar with JWS, even with the help of a JWS library, both verification steps can be easily missed since it only affects the verification, not the decoding of the message.</p>

<p>In the section next, we will have an example about how to decode the message while really verify the message is sent by Apple as well.</p>

<h2 id="4-decode-and-verify-notification">4. Decode and Verify Notification</h2>

<p>Here we are using <a href="https://developer.apple.com/documentation/appstoreservernotifications/app_store_server_notifications_v2">App Store server notifications v2</a>. Let’s say you’ve already got the http POST body from your configured endpoint:</p>

<div class="language-Scala highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>val responseBodyV2Str: String = ... // your code to get POST body from HTTP request
</pre></div>
</div>
</div>

<p><code>responseBodyV2Str</code> itself is not a JWS object but a JSON string like this:</p>

<div class="language-plaintext highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>{&quot;signedPayload&quot;:&quot;eyJhbGciOiJFUzI1NiIsIng1YyI6WyJNSUlFTU....&quot;}
</pre></div>
</div>
</div>

<p>The value of <code>signedPayload</code> is the encoded JWS string we want to parse. So we need to get that value first. I’m using <a href="https://circe.github.io/circe/">circe</a> to parse the JSON string, but any method that can parse it and get the value is fine. In my case, I defined some classes based on the JSON structures so that we can parse them in a more type safe way.</p>

<div class="language-Scala highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>import io.circe.generic.extras._
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>import io.circe.parser
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>object ApplePaymentService {
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>  implicit val config: Configuration = Configuration.default.withDefaults
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>  @ConfiguredJsonCodec case class AppleResponseBodyV2(
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>    signedPayload: String,
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>  )
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>  @ConfiguredJsonCodec case class AppleResponseBodyV2DecodedPayload(
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>    notificationType: String,
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>    subtype: Option[String],
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>    data: ApplePayloadData,
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>  )
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>  @ConfiguredJsonCodec case class ApplePayloadData(
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>    appAppleId: Option[String],
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>    bundleId: String,
<span class="line-numbers"><a href="#n22" name="n22">22</a></span>    bundleVersion: String,
<span class="line-numbers"><a href="#n23" name="n23">23</a></span>    environment: String,
<span class="line-numbers"><a href="#n24" name="n24">24</a></span>    signedRenewalInfo: String,
<span class="line-numbers"><a href="#n25" name="n25">25</a></span>    signedTransactionInfo: String,
<span class="line-numbers"><a href="#n26" name="n26">26</a></span>  )
<span class="line-numbers"><a href="#n27" name="n27">27</a></span>
<span class="line-numbers"><a href="#n28" name="n28">28</a></span>  @ConfiguredJsonCodec case class AppleJWSTransactionDecodedPayload(
<span class="line-numbers"><a href="#n29" name="n29">29</a></span>    appAccountToken: String,
<span class="line-numbers"><strong><a href="#n30" name="n30">30</a></strong></span>    bundleId: String,
<span class="line-numbers"><a href="#n31" name="n31">31</a></span>    environment: String,
<span class="line-numbers"><a href="#n32" name="n32">32</a></span>    expiresDate: Long, // timestamp in ms
<span class="line-numbers"><a href="#n33" name="n33">33</a></span>    inAppOwnershipType: String,
<span class="line-numbers"><a href="#n34" name="n34">34</a></span>    originalPurchaseDate: Long, // timestamp in ms
<span class="line-numbers"><a href="#n35" name="n35">35</a></span>    originalTransactionId: String,
<span class="line-numbers"><a href="#n36" name="n36">36</a></span>    productId: String,
<span class="line-numbers"><a href="#n37" name="n37">37</a></span>    purchaseDate: Long, // timestamp in ms
<span class="line-numbers"><a href="#n38" name="n38">38</a></span>    quantity: Int,
<span class="line-numbers"><a href="#n39" name="n39">39</a></span>    transactionId: String,
<span class="line-numbers"><strong><a href="#n40" name="n40">40</a></strong></span>    `type`: String,
<span class="line-numbers"><a href="#n41" name="n41">41</a></span>    webOrderLineItemId: String,
<span class="line-numbers"><a href="#n42" name="n42">42</a></span>  )
<span class="line-numbers"><a href="#n43" name="n43">43</a></span>}
</pre></div>
</div>
</div>

<p>With the help with the classes and JSON parser, we can get the value of <code>signedPayload</code>. (I removed <code>\n</code> from the JSON string since it’s not valid to have newlines in JSON string, not sure why Apple’s request body has newline in it):</p>

<div class="language-plaintext highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>val responseBodyV2 = parser.parse(responseBodyV2Str.replace(&quot;\n&quot;, &quot;&quot;)).flatMap(_.as[AppleResponseBodyV2]).toTry.get
</pre></div>
</div>
</div>

<p>After get the JWS string, we can parse it with <a href="https://connect2id.com/products/nimbus-jose-jwt/examples">Numbus Jose + JWT</a> (follow the document to add this dependency into your project first):</p>

<div class="language-plaintext highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>import com.nimbusds.jose.JWSObject
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>import com.nimbusds.jose.crypto.ECDSAVerifier
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>import com.nimbusds.jose.crypto.bc.BouncyCastleProviderSingleton
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>import com.nimbusds.jose.jwk.ECKey
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>import com.nimbusds.jose.util.X509CertUtils
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>val jwsObject = JWSObject.parse(responseBodyV2.signedPayload)
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>val jwsCerts = jwsObject.getHeader.getX509CertChain.asScala.map(c =&gt; X509CertUtils.parse(c.decode()))
</pre></div>
</div>
</div>

<h3 id="41-verify-keys-in-jws-header-is-signed-by-apple">4.1 Verify keys in JWS header is signed by Apple</h3>

<p><code>jwsCerts</code> is a list of <code>X509Certificate</code>, which is the key chain in JWS header. A cert in the list can be verified by the cert behind it. And the last cert should be verified by Apple’s public key so that we can make sure the whole key chain is signed by Apple.</p>

<p>So let’s first get the root cert of Apple first: download <a href="https://www.apple.com/certificateauthority/AppleRootCA-G3.cer">Apple Root CA - G3 Root</a> from <a href="https://www.apple.com/certificateauthority/">Apple PKI website</a> and put it under your project’s <code>src/resources/certs</code> (or any where the program can read, we are just using it as an example here). Then we can read the Apple root cert with this code:</p>

<div class="language-plaintext highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>val appleRootCa = X509CertUtils.parse(getClass.getResourceAsStream(&quot;/certs/AppleRootCA-G3.cer&quot;).readAllBytes())
</pre></div>
</div>
</div>

<p>With both the key chain and root cert, we can verify the key chain is both valid and signed by Apple:</p>

<div class="language-plaintext highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>jwsCerts.sliding(2).foreach { x =&gt;
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>  x.head.verify(x.last.getPublicKey)
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>}
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>jwsCerts.last.verify(appleRootCa.getPublicKey)
</pre></div>
</div>
</div>

<p>It will throw exception if the verify doesn’t pass.</p>

<h3 id="42-verify-jws-is-signed-by-keys-in-jws-header">4.2 Verify JWS is signed by keys in JWS header</h3>

<p>Once we verified the keys in JWS header is signed by Apple, we need to verify JWS itself is signed by these keys. Since the <code>alg</code> field in this JWS header is <code>ES256</code>, we will use <code>ECDSAVerifier</code> to verify it:</p>

<div class="language-plaintext highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>val jwk = ECKey.parse(jwsCerts.head)
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>val jwsVerifier = new ECDSAVerifier(jwk)
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>if (!jwsObject.verify(jwsVerifier)) {
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>  throw new RuntimeException(&quot;Apple JWS object cannot be verified&quot;)
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>}
</pre></div>
</div>
</div>

<h3 id="43-parse-the-payload">4.3 Parse the payload</h3>

<p>After verify the JWS is valid, we can start to parse the payload. I’m using the JSON parser and the structure I defined above. Please refer to Apple’s document about the actual fields in the payload:</p>

<div class="language-plaintext highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>val responseBodyV2Payload = jwsObject.getPayload.toString
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>val responseBodyV2DecodedPayload = parser.parse(responseBodyV2Payload).flatMap(_.as[AppleResponseBodyV2DecodedPayload]).toTry.get
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>val transactionPayload = responseBodyV2DecodedPayload.data.signedTransactionInfo
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>val transactionDecodedPayloadStr = JWSObject.parse(transactionPayload).getPayload.toString
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>val transactionDecodedPayload = parser.parse(transactionDecodedPayloadStr).flatMap(_.as[AppleJWSTransactionDecodedPayload]).toTry.get
</pre></div>
</div>
</div>

<p>Here we have the detailed transaction information in <code>transactionDecodedPayload</code> and can hand it with our business logic.</p>

<p>There is an interesting thing: <code>signedRenewInfo</code> and <code>signedTrasactionInfo</code> are both encoded with JWS again in payload data. I don’t know why: since we’ve already verified the whole payload is signed by Apple, all the content in it should already be valid as well, what’s the point to sign the fields again? I just decoded the fields with <code>JWSObject.parse</code> but you can always verify it with the same method above just to be safe.</p>

<h2 id="5-other-thoughts">5. Other Thoughts</h2>

<p>As I said about a <a href="/2020-11-08-DNS-Resolving-Bug-in-iOS-14.html">previous blog about an iOS bug</a>, I really hate Apple’s close ecosystem. But Apple’s hardware is good and has a large user space, so we cannot avoid it. Hopefully Android can be better at permission management and other mobile OS can also catch up.</p>

</article>

<footer id="post_footer">
  <table><tr>
    
      <td id="prev"><a href="/2022-05-02-A-Library-to-Make-It-Easier-to-Use-Scala-with-GRPC.html">Prev: A Library to Make It Easier to Use Scala with gRPC</a></td>
    
    
      <td id="next"><a href="/2022-10-29-RSS-Brain-Yet-Another-RSS-Reader-With-More-Features.html" id="next">Next: RSS Brain: Yet Another RSS Reader, With More Features</a></td>
    
  </tr></table>
</footer>

<section id="comment">
  <div id="disqus_thread"></div>
  <script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'crazy-hot-ice'; // required: replace example with your forum shortname
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</section>



<!-- MathJax -->
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>

</div>

    </section>

    <footer id="page_footer">
      Copyright @ 2008 - 2023 Bin Wang
      <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US">Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License</a>.
    </footer>
  </body>
</html>
