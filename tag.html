<!DOCTYPE html>

<html>
  <head>
    <title> Crazy Hot Ice</title>
    <link rel="stylesheet" href="/static/css/default.css" type="text/css" />

    <!-- for google analytic --!>
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-26103883-3']);
      _gaq.push(['_trackPageview']);
    
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </head>

  <body>
    <header id="page_header">
      <h1>Crazy Hot Ice</h1>
      <h2 id="description">Learning, Researching, Sharing</h2>

      <nav id="page_nav">
      <table><tr>
         <td id="cat"><ul>
           <li>Categories:</li>
           
             
               <li><a href="/categories/workspace">workspace</a></li>
             
           
             
               <li><a href="/categories/notes">notes</a></li>
             
           
         </ul></td>
         <td id="page"><ul>
           
             <li><a href="/">home</a></li>
           
           
             <li><a href="/search.html">search</a></li>
           
             <li><a href="/feed.xml">feed</a></li>
          </ul></td>
      </tr></table>
      </nav>

    </header>

    <section id="page_content">
      <script type="text/javascript">
  function init() {
    var posts = {};
    var tags = {};
    
      posts[{"layout"=>"post", "title"=>"Backup My Dotfiles", "categories"=>["workspace"], "tags"=>["vim", "zsh", "config", "git"], "url"=>"/workspace/2012/12/05/Backup-My-Dotfiles.html", "date"=>2012-12-05 00:00:00 +0800, "id"=>"/workspace/2012/12/05/Backup-My-Dotfiles", "next"=>nil, "previous"=><Post: /notes/2012/11/27/Compile-And-Install-Kernel>, "content"=>"<p>These days I re-configure my vim and zsh. Then backup them in <a href='http://github.com'>github</a>. You can see it at <a href='https://github.com/wb14123/dotfiles'>here</a>.</p>\n\n<p>Using github to backup dotfiles is really a comfortable way. In this way, you can:</p>\n\n<ul>\n<li>Feel free to change your configures, since if you don&#8217;t like the configure some day, you can roll it back.</li>\n\n<li>Update your configures anywhere. Just use git to clone your configure files from github.</li>\n\n<li>Keep different versions for different machines (Such as for desktop and laptop). Just use branch to control them.</li>\n\n<li>If you are using vim plugins from git repo or something like <a href='https://github.com/robbyrussell/oh-my-zsh'>oh-my-zsh</a>, you could simple use git submodule to keep track of them.</li>\n</ul>\n\n<p>The basic idea is put configure files in a directory such as <code>dotfile</code> and use git to track it. Then make a symbolic link to home. However, manual make symbolic links is boring. Firstly I am thinking of use the same directory structure as <code>~/</code> and then automatic link them. But there comes some problems: for some directories such as <code>.vim</code>, we should make a link for them while for some directories such as <code>.config</code>, we may only want to link <code>openbox</code> under it to <code>~/.config/openbox</code>. It seems impossible to use an automatic way totally. But some shell code could make life a little easy:</p>\n\n<pre><code>check_link() {\n\tLINK=`pwd`/$1\n\tTARGET=~/$2\n\tif [ -h $TARGET ] ; then\n\t\techo -n &quot;remove symbolic link: &quot;\n\t\trm -v $TARGET\n\telif [ -e $TARGET ] ; then\n\t\techo -n &quot;move: &quot;\n\t\tmv -v $TARGET $TARGET.old\n\tfi\n\techo -n &quot;link: &quot;\n\tln -sv $LINK $TARGET\n}</code></pre>\n\n<p>Usage: <code>check_link &lt;path_in_dotfiles&gt; &lt;path_in_home&gt;</code>, such as <code>check_link vim/vimrc .vimrc</code>. See <a href='https://github.com/wb14123/dotfiles/blob/master/link.sh'>my github repo</a> for details.</p>"}] = [];
      
        posts[{"layout"=>"post", "title"=>"Backup My Dotfiles", "categories"=>["workspace"], "tags"=>["vim", "zsh", "config", "git"], "url"=>"/workspace/2012/12/05/Backup-My-Dotfiles.html", "date"=>2012-12-05 00:00:00 +0800, "id"=>"/workspace/2012/12/05/Backup-My-Dotfiles", "next"=>nil, "previous"=><Post: /notes/2012/11/27/Compile-And-Install-Kernel>, "content"=>"<p>These days I re-configure my vim and zsh. Then backup them in <a href='http://github.com'>github</a>. You can see it at <a href='https://github.com/wb14123/dotfiles'>here</a>.</p>\n\n<p>Using github to backup dotfiles is really a comfortable way. In this way, you can:</p>\n\n<ul>\n<li>Feel free to change your configures, since if you don&#8217;t like the configure some day, you can roll it back.</li>\n\n<li>Update your configures anywhere. Just use git to clone your configure files from github.</li>\n\n<li>Keep different versions for different machines (Such as for desktop and laptop). Just use branch to control them.</li>\n\n<li>If you are using vim plugins from git repo or something like <a href='https://github.com/robbyrussell/oh-my-zsh'>oh-my-zsh</a>, you could simple use git submodule to keep track of them.</li>\n</ul>\n\n<p>The basic idea is put configure files in a directory such as <code>dotfile</code> and use git to track it. Then make a symbolic link to home. However, manual make symbolic links is boring. Firstly I am thinking of use the same directory structure as <code>~/</code> and then automatic link them. But there comes some problems: for some directories such as <code>.vim</code>, we should make a link for them while for some directories such as <code>.config</code>, we may only want to link <code>openbox</code> under it to <code>~/.config/openbox</code>. It seems impossible to use an automatic way totally. But some shell code could make life a little easy:</p>\n\n<pre><code>check_link() {\n\tLINK=`pwd`/$1\n\tTARGET=~/$2\n\tif [ -h $TARGET ] ; then\n\t\techo -n &quot;remove symbolic link: &quot;\n\t\trm -v $TARGET\n\telif [ -e $TARGET ] ; then\n\t\techo -n &quot;move: &quot;\n\t\tmv -v $TARGET $TARGET.old\n\tfi\n\techo -n &quot;link: &quot;\n\tln -sv $LINK $TARGET\n}</code></pre>\n\n<p>Usage: <code>check_link &lt;path_in_dotfiles&gt; &lt;path_in_home&gt;</code>, such as <code>check_link vim/vimrc .vimrc</code>. See <a href='https://github.com/wb14123/dotfiles/blob/master/link.sh'>my github repo</a> for details.</p>"}].push(vim);
        if (tags[vim] === undefined) {
          tags[vim] = 1;
        }
        tags[vim] +=  1;
      
        posts[{"layout"=>"post", "title"=>"Backup My Dotfiles", "categories"=>["workspace"], "tags"=>["vim", "zsh", "config", "git"], "url"=>"/workspace/2012/12/05/Backup-My-Dotfiles.html", "date"=>2012-12-05 00:00:00 +0800, "id"=>"/workspace/2012/12/05/Backup-My-Dotfiles", "next"=>nil, "previous"=><Post: /notes/2012/11/27/Compile-And-Install-Kernel>, "content"=>"<p>These days I re-configure my vim and zsh. Then backup them in <a href='http://github.com'>github</a>. You can see it at <a href='https://github.com/wb14123/dotfiles'>here</a>.</p>\n\n<p>Using github to backup dotfiles is really a comfortable way. In this way, you can:</p>\n\n<ul>\n<li>Feel free to change your configures, since if you don&#8217;t like the configure some day, you can roll it back.</li>\n\n<li>Update your configures anywhere. Just use git to clone your configure files from github.</li>\n\n<li>Keep different versions for different machines (Such as for desktop and laptop). Just use branch to control them.</li>\n\n<li>If you are using vim plugins from git repo or something like <a href='https://github.com/robbyrussell/oh-my-zsh'>oh-my-zsh</a>, you could simple use git submodule to keep track of them.</li>\n</ul>\n\n<p>The basic idea is put configure files in a directory such as <code>dotfile</code> and use git to track it. Then make a symbolic link to home. However, manual make symbolic links is boring. Firstly I am thinking of use the same directory structure as <code>~/</code> and then automatic link them. But there comes some problems: for some directories such as <code>.vim</code>, we should make a link for them while for some directories such as <code>.config</code>, we may only want to link <code>openbox</code> under it to <code>~/.config/openbox</code>. It seems impossible to use an automatic way totally. But some shell code could make life a little easy:</p>\n\n<pre><code>check_link() {\n\tLINK=`pwd`/$1\n\tTARGET=~/$2\n\tif [ -h $TARGET ] ; then\n\t\techo -n &quot;remove symbolic link: &quot;\n\t\trm -v $TARGET\n\telif [ -e $TARGET ] ; then\n\t\techo -n &quot;move: &quot;\n\t\tmv -v $TARGET $TARGET.old\n\tfi\n\techo -n &quot;link: &quot;\n\tln -sv $LINK $TARGET\n}</code></pre>\n\n<p>Usage: <code>check_link &lt;path_in_dotfiles&gt; &lt;path_in_home&gt;</code>, such as <code>check_link vim/vimrc .vimrc</code>. See <a href='https://github.com/wb14123/dotfiles/blob/master/link.sh'>my github repo</a> for details.</p>"}].push(zsh);
        if (tags[zsh] === undefined) {
          tags[zsh] = 1;
        }
        tags[zsh] +=  1;
      
        posts[{"layout"=>"post", "title"=>"Backup My Dotfiles", "categories"=>["workspace"], "tags"=>["vim", "zsh", "config", "git"], "url"=>"/workspace/2012/12/05/Backup-My-Dotfiles.html", "date"=>2012-12-05 00:00:00 +0800, "id"=>"/workspace/2012/12/05/Backup-My-Dotfiles", "next"=>nil, "previous"=><Post: /notes/2012/11/27/Compile-And-Install-Kernel>, "content"=>"<p>These days I re-configure my vim and zsh. Then backup them in <a href='http://github.com'>github</a>. You can see it at <a href='https://github.com/wb14123/dotfiles'>here</a>.</p>\n\n<p>Using github to backup dotfiles is really a comfortable way. In this way, you can:</p>\n\n<ul>\n<li>Feel free to change your configures, since if you don&#8217;t like the configure some day, you can roll it back.</li>\n\n<li>Update your configures anywhere. Just use git to clone your configure files from github.</li>\n\n<li>Keep different versions for different machines (Such as for desktop and laptop). Just use branch to control them.</li>\n\n<li>If you are using vim plugins from git repo or something like <a href='https://github.com/robbyrussell/oh-my-zsh'>oh-my-zsh</a>, you could simple use git submodule to keep track of them.</li>\n</ul>\n\n<p>The basic idea is put configure files in a directory such as <code>dotfile</code> and use git to track it. Then make a symbolic link to home. However, manual make symbolic links is boring. Firstly I am thinking of use the same directory structure as <code>~/</code> and then automatic link them. But there comes some problems: for some directories such as <code>.vim</code>, we should make a link for them while for some directories such as <code>.config</code>, we may only want to link <code>openbox</code> under it to <code>~/.config/openbox</code>. It seems impossible to use an automatic way totally. But some shell code could make life a little easy:</p>\n\n<pre><code>check_link() {\n\tLINK=`pwd`/$1\n\tTARGET=~/$2\n\tif [ -h $TARGET ] ; then\n\t\techo -n &quot;remove symbolic link: &quot;\n\t\trm -v $TARGET\n\telif [ -e $TARGET ] ; then\n\t\techo -n &quot;move: &quot;\n\t\tmv -v $TARGET $TARGET.old\n\tfi\n\techo -n &quot;link: &quot;\n\tln -sv $LINK $TARGET\n}</code></pre>\n\n<p>Usage: <code>check_link &lt;path_in_dotfiles&gt; &lt;path_in_home&gt;</code>, such as <code>check_link vim/vimrc .vimrc</code>. See <a href='https://github.com/wb14123/dotfiles/blob/master/link.sh'>my github repo</a> for details.</p>"}].push(config);
        if (tags[config] === undefined) {
          tags[config] = 1;
        }
        tags[config] +=  1;
      
        posts[{"layout"=>"post", "title"=>"Backup My Dotfiles", "categories"=>["workspace"], "tags"=>["vim", "zsh", "config", "git"], "url"=>"/workspace/2012/12/05/Backup-My-Dotfiles.html", "date"=>2012-12-05 00:00:00 +0800, "id"=>"/workspace/2012/12/05/Backup-My-Dotfiles", "next"=>nil, "previous"=><Post: /notes/2012/11/27/Compile-And-Install-Kernel>, "content"=>"<p>These days I re-configure my vim and zsh. Then backup them in <a href='http://github.com'>github</a>. You can see it at <a href='https://github.com/wb14123/dotfiles'>here</a>.</p>\n\n<p>Using github to backup dotfiles is really a comfortable way. In this way, you can:</p>\n\n<ul>\n<li>Feel free to change your configures, since if you don&#8217;t like the configure some day, you can roll it back.</li>\n\n<li>Update your configures anywhere. Just use git to clone your configure files from github.</li>\n\n<li>Keep different versions for different machines (Such as for desktop and laptop). Just use branch to control them.</li>\n\n<li>If you are using vim plugins from git repo or something like <a href='https://github.com/robbyrussell/oh-my-zsh'>oh-my-zsh</a>, you could simple use git submodule to keep track of them.</li>\n</ul>\n\n<p>The basic idea is put configure files in a directory such as <code>dotfile</code> and use git to track it. Then make a symbolic link to home. However, manual make symbolic links is boring. Firstly I am thinking of use the same directory structure as <code>~/</code> and then automatic link them. But there comes some problems: for some directories such as <code>.vim</code>, we should make a link for them while for some directories such as <code>.config</code>, we may only want to link <code>openbox</code> under it to <code>~/.config/openbox</code>. It seems impossible to use an automatic way totally. But some shell code could make life a little easy:</p>\n\n<pre><code>check_link() {\n\tLINK=`pwd`/$1\n\tTARGET=~/$2\n\tif [ -h $TARGET ] ; then\n\t\techo -n &quot;remove symbolic link: &quot;\n\t\trm -v $TARGET\n\telif [ -e $TARGET ] ; then\n\t\techo -n &quot;move: &quot;\n\t\tmv -v $TARGET $TARGET.old\n\tfi\n\techo -n &quot;link: &quot;\n\tln -sv $LINK $TARGET\n}</code></pre>\n\n<p>Usage: <code>check_link &lt;path_in_dotfiles&gt; &lt;path_in_home&gt;</code>, such as <code>check_link vim/vimrc .vimrc</code>. See <a href='https://github.com/wb14123/dotfiles/blob/master/link.sh'>my github repo</a> for details.</p>"}].push(git);
        if (tags[git] === undefined) {
          tags[git] = 1;
        }
        tags[git] +=  1;
      
    
      posts[{"layout"=>"post", "title"=>"Compile And Install Kernel", "categories"=>["notes"], "tags"=>["linux", "kernel"], "url"=>"/notes/2012/11/27/Compile-And-Install-Kernel.html", "date"=>2012-11-27 00:00:00 +0800, "id"=>"/notes/2012/11/27/Compile-And-Install-Kernel", "next"=><Post: /workspace/2012/12/05/Backup-My-Dotfiles>, "previous"=><Post: /workspace/2012/11/20/Comment-And-Search-Are-Available>, "content"=>"<p>There are already many documents to teach one how to compile and install kernel. Here are just some key notes. Use <code>make help</code> under source directory for details.</p>\n\n<h2 id='0_kernel_configure'>0. Kernel configure</h2>\n\n<p>It is happy to have a kernel git repo. Using <code>git tag</code> to see the kernel versions and use <code>git checkout &lt;tag&gt;</code> to checkout the specified version, such as:</p>\n\n<pre><code>git checkout v3.7-rc6</code></pre>\n\n<p>It is recommended to use the distribution&#8217;s kernel configure file as a basic configure when you compile the kernel for the first time. Copy it from <code>/boot</code> to <code>&lt;build_dir&gt;/.config</code>. Use this command to modify it:</p>\n\n<pre><code>make O=&lt;build_dir&gt; menuconfig</code></pre>\n\n<p>It will save the new configure and rename the old configure with <code>.config.old</code>.</p>\n\n<h2 id='1_kernel_image'>1. Kernel image</h2>\n\n<p>Kernel image is the most important part. Use this command to compile kernel in <code>&lt;build_dir&gt;</code>:</p>\n\n<pre><code>make O=&lt;build_dir&gt; -j4</code></pre>\n\n<p>After that, Copy <code>vmlinux</code> and <code>System.map</code> to <code>/boot</code>. And then configure the boot loader. Or use the command <code>installkernel</code> if you have it.</p>\n\n<h2 id='2_kernel_modules'>2. Kernel modules</h2>\n\n<p>Some code are compiled to kernel modules. It need to be installed to the system. Use this command to install kernel modules and firmwares:</p>\n\n<pre><code>make O=&lt;build_dir&gt; modules_install</code></pre>\n\n<p>It installs kernel modules under <code>/usr/lib/modules/&lt;kernel_version&gt;</code>. You can also specify the output directory using <code>INSTALL_MOD_PATH</code>:</p>\n\n<pre><code>make O=&lt;build_dir&gt; INSTALL_MOD_PATH=&lt;module_dir&gt; modules_install</code></pre>\n\n<p>The <code>INSTALL_MOD_PATH</code> is <code>/</code> by default.</p>\n\n<h2 id='3_linux_headers'>3. Linux headers</h2>\n\n<p>Linux headers are some header files to invoked by user space programs. Using this command to output it:</p>\n\n<pre><code>make O=&lt;build_dir&gt; INSTALL_HDR_PATH=&lt;headers_dir&gt; headers_install</code></pre>\n\n<p>It installs headers to <code>&lt;headers_dir&gt;</code>. You should copy them into <code>/usr/include</code>.</p>\n\n<h2 id='another_way'>Another way</h2>\n\n<p>After all, you may want to make a kernel package to install on other machines. Such as:</p>\n\n<pre><code>make O=&lt;build_dir&gt; -j4 binrpm-pkg</code></pre>"}] = [];
      
        posts[{"layout"=>"post", "title"=>"Compile And Install Kernel", "categories"=>["notes"], "tags"=>["linux", "kernel"], "url"=>"/notes/2012/11/27/Compile-And-Install-Kernel.html", "date"=>2012-11-27 00:00:00 +0800, "id"=>"/notes/2012/11/27/Compile-And-Install-Kernel", "next"=><Post: /workspace/2012/12/05/Backup-My-Dotfiles>, "previous"=><Post: /workspace/2012/11/20/Comment-And-Search-Are-Available>, "content"=>"<p>There are already many documents to teach one how to compile and install kernel. Here are just some key notes. Use <code>make help</code> under source directory for details.</p>\n\n<h2 id='0_kernel_configure'>0. Kernel configure</h2>\n\n<p>It is happy to have a kernel git repo. Using <code>git tag</code> to see the kernel versions and use <code>git checkout &lt;tag&gt;</code> to checkout the specified version, such as:</p>\n\n<pre><code>git checkout v3.7-rc6</code></pre>\n\n<p>It is recommended to use the distribution&#8217;s kernel configure file as a basic configure when you compile the kernel for the first time. Copy it from <code>/boot</code> to <code>&lt;build_dir&gt;/.config</code>. Use this command to modify it:</p>\n\n<pre><code>make O=&lt;build_dir&gt; menuconfig</code></pre>\n\n<p>It will save the new configure and rename the old configure with <code>.config.old</code>.</p>\n\n<h2 id='1_kernel_image'>1. Kernel image</h2>\n\n<p>Kernel image is the most important part. Use this command to compile kernel in <code>&lt;build_dir&gt;</code>:</p>\n\n<pre><code>make O=&lt;build_dir&gt; -j4</code></pre>\n\n<p>After that, Copy <code>vmlinux</code> and <code>System.map</code> to <code>/boot</code>. And then configure the boot loader. Or use the command <code>installkernel</code> if you have it.</p>\n\n<h2 id='2_kernel_modules'>2. Kernel modules</h2>\n\n<p>Some code are compiled to kernel modules. It need to be installed to the system. Use this command to install kernel modules and firmwares:</p>\n\n<pre><code>make O=&lt;build_dir&gt; modules_install</code></pre>\n\n<p>It installs kernel modules under <code>/usr/lib/modules/&lt;kernel_version&gt;</code>. You can also specify the output directory using <code>INSTALL_MOD_PATH</code>:</p>\n\n<pre><code>make O=&lt;build_dir&gt; INSTALL_MOD_PATH=&lt;module_dir&gt; modules_install</code></pre>\n\n<p>The <code>INSTALL_MOD_PATH</code> is <code>/</code> by default.</p>\n\n<h2 id='3_linux_headers'>3. Linux headers</h2>\n\n<p>Linux headers are some header files to invoked by user space programs. Using this command to output it:</p>\n\n<pre><code>make O=&lt;build_dir&gt; INSTALL_HDR_PATH=&lt;headers_dir&gt; headers_install</code></pre>\n\n<p>It installs headers to <code>&lt;headers_dir&gt;</code>. You should copy them into <code>/usr/include</code>.</p>\n\n<h2 id='another_way'>Another way</h2>\n\n<p>After all, you may want to make a kernel package to install on other machines. Such as:</p>\n\n<pre><code>make O=&lt;build_dir&gt; -j4 binrpm-pkg</code></pre>"}].push(linux);
        if (tags[linux] === undefined) {
          tags[linux] = 1;
        }
        tags[linux] +=  1;
      
        posts[{"layout"=>"post", "title"=>"Compile And Install Kernel", "categories"=>["notes"], "tags"=>["linux", "kernel"], "url"=>"/notes/2012/11/27/Compile-And-Install-Kernel.html", "date"=>2012-11-27 00:00:00 +0800, "id"=>"/notes/2012/11/27/Compile-And-Install-Kernel", "next"=><Post: /workspace/2012/12/05/Backup-My-Dotfiles>, "previous"=><Post: /workspace/2012/11/20/Comment-And-Search-Are-Available>, "content"=>"<p>There are already many documents to teach one how to compile and install kernel. Here are just some key notes. Use <code>make help</code> under source directory for details.</p>\n\n<h2 id='0_kernel_configure'>0. Kernel configure</h2>\n\n<p>It is happy to have a kernel git repo. Using <code>git tag</code> to see the kernel versions and use <code>git checkout &lt;tag&gt;</code> to checkout the specified version, such as:</p>\n\n<pre><code>git checkout v3.7-rc6</code></pre>\n\n<p>It is recommended to use the distribution&#8217;s kernel configure file as a basic configure when you compile the kernel for the first time. Copy it from <code>/boot</code> to <code>&lt;build_dir&gt;/.config</code>. Use this command to modify it:</p>\n\n<pre><code>make O=&lt;build_dir&gt; menuconfig</code></pre>\n\n<p>It will save the new configure and rename the old configure with <code>.config.old</code>.</p>\n\n<h2 id='1_kernel_image'>1. Kernel image</h2>\n\n<p>Kernel image is the most important part. Use this command to compile kernel in <code>&lt;build_dir&gt;</code>:</p>\n\n<pre><code>make O=&lt;build_dir&gt; -j4</code></pre>\n\n<p>After that, Copy <code>vmlinux</code> and <code>System.map</code> to <code>/boot</code>. And then configure the boot loader. Or use the command <code>installkernel</code> if you have it.</p>\n\n<h2 id='2_kernel_modules'>2. Kernel modules</h2>\n\n<p>Some code are compiled to kernel modules. It need to be installed to the system. Use this command to install kernel modules and firmwares:</p>\n\n<pre><code>make O=&lt;build_dir&gt; modules_install</code></pre>\n\n<p>It installs kernel modules under <code>/usr/lib/modules/&lt;kernel_version&gt;</code>. You can also specify the output directory using <code>INSTALL_MOD_PATH</code>:</p>\n\n<pre><code>make O=&lt;build_dir&gt; INSTALL_MOD_PATH=&lt;module_dir&gt; modules_install</code></pre>\n\n<p>The <code>INSTALL_MOD_PATH</code> is <code>/</code> by default.</p>\n\n<h2 id='3_linux_headers'>3. Linux headers</h2>\n\n<p>Linux headers are some header files to invoked by user space programs. Using this command to output it:</p>\n\n<pre><code>make O=&lt;build_dir&gt; INSTALL_HDR_PATH=&lt;headers_dir&gt; headers_install</code></pre>\n\n<p>It installs headers to <code>&lt;headers_dir&gt;</code>. You should copy them into <code>/usr/include</code>.</p>\n\n<h2 id='another_way'>Another way</h2>\n\n<p>After all, you may want to make a kernel package to install on other machines. Such as:</p>\n\n<pre><code>make O=&lt;build_dir&gt; -j4 binrpm-pkg</code></pre>"}].push(kernel);
        if (tags[kernel] === undefined) {
          tags[kernel] = 1;
        }
        tags[kernel] +=  1;
      
    
      posts[{"layout"=>"post", "title"=>"Comment And Search Are Available", "categories"=>["workspace"], "tags"=>["blog", "disqus", "google"], "url"=>"/workspace/2012/11/20/Comment-And-Search-Are-Available.html", "date"=>2012-11-20 00:00:00 +0800, "id"=>"/workspace/2012/11/20/Comment-And-Search-Are-Available", "next"=><Post: /notes/2012/11/27/Compile-And-Install-Kernel>, "previous"=><Post: /workspace/2012/11/19/my-new-blog>, "content"=>"<p>As you can see, my blog are able to comment and search now!</p>\n\n<h2 id='comment'>Comment</h2>\n\n<p>I always think comment is very important for a blog. You can know how helpful or is there some issues in your article. <a href='http://disqus.com'>Disqus</a> is a great tool to put comment on a website. It is neat and powerful as you can see. It may be a little slow in China. But consider of my blog are mostly written in English, it is not a big deal.</p>\n\n<h2 id='search'>Search</h2>\n\n<p>The search engine I am using is <a href='http://www.google.com/cse'>Google custom search engine</a>. Isn&#8217;t it awesome I have google&#8217;s technology on my blog? It is easy to use, too. The badness of this choice is google may take some time to put the website&#8217;s content into its index. And google is even not available in China sometimes.</p>\n\n<h2 id='scripts_to_make_life_easy'>Scripts to Make Life Easy</h2>\n\n<p>As I put the website on <a href='http://pages.github.com/'>github page</a>, I don&#8217;t want to upload the jekyll directory. Just the static site is enough. So I must copy the site to git repository, add, commit and then push it. It is a boring work. I write two scripts to make it easy. I don&#8217;t know if there is some other way to do this, but I&#8217;m OK with it.</p>\n\n<p>update.sh: generate static site and upload to github.</p>\n\n<pre><code>#!/bin/bash\n\nBASE_DIR=`pwd`\nJ_DIR=&quot;./jekyll&quot;\nGIT_DIR=&quot;./wb14123.github.com&quot;\n\ncd $J_DIR\njekyll\ncd $BASE_DIR\nrm -r $GIT_DIR/*\ncp -r $J_DIR/_site/* $GIT_DIR/\ncd $GIT_DIR\ngit add -A .\ngit commit -m &quot;Changed at $(date)&quot;\ngit push origin master\nexit $?</code></pre>\n\n<p>newpost.sh: use vim to open a new post with current time and some meta information.</p>\n\n<pre><code>#!/bin/bash\n\nif [ $# -lt 1 ]\nthen\n    echo &quot;newpost: You need to specify the post name.&quot;\n    exit 1\nfi\n\nPOST_NAME=$1\nPOST_DATE=`date +%Y-%m-%d`\nPOST_DIR=&quot;./jekyll/_posts&quot;\nFILE_NAME=`echo &quot;$POST_DIR/$POST_DATE-$POST_NAME.md&quot; | sed &quot;s/ /-/g&quot;`\n\necho &quot;\n---\nlayout: post\ntitle: $POST_NAME\ncategories: misc\ntags: []\n---\n&quot; &gt; $FILE_NAME\n\nvim $FILE_NAME</code></pre>"}] = [];
      
        posts[{"layout"=>"post", "title"=>"Comment And Search Are Available", "categories"=>["workspace"], "tags"=>["blog", "disqus", "google"], "url"=>"/workspace/2012/11/20/Comment-And-Search-Are-Available.html", "date"=>2012-11-20 00:00:00 +0800, "id"=>"/workspace/2012/11/20/Comment-And-Search-Are-Available", "next"=><Post: /notes/2012/11/27/Compile-And-Install-Kernel>, "previous"=><Post: /workspace/2012/11/19/my-new-blog>, "content"=>"<p>As you can see, my blog are able to comment and search now!</p>\n\n<h2 id='comment'>Comment</h2>\n\n<p>I always think comment is very important for a blog. You can know how helpful or is there some issues in your article. <a href='http://disqus.com'>Disqus</a> is a great tool to put comment on a website. It is neat and powerful as you can see. It may be a little slow in China. But consider of my blog are mostly written in English, it is not a big deal.</p>\n\n<h2 id='search'>Search</h2>\n\n<p>The search engine I am using is <a href='http://www.google.com/cse'>Google custom search engine</a>. Isn&#8217;t it awesome I have google&#8217;s technology on my blog? It is easy to use, too. The badness of this choice is google may take some time to put the website&#8217;s content into its index. And google is even not available in China sometimes.</p>\n\n<h2 id='scripts_to_make_life_easy'>Scripts to Make Life Easy</h2>\n\n<p>As I put the website on <a href='http://pages.github.com/'>github page</a>, I don&#8217;t want to upload the jekyll directory. Just the static site is enough. So I must copy the site to git repository, add, commit and then push it. It is a boring work. I write two scripts to make it easy. I don&#8217;t know if there is some other way to do this, but I&#8217;m OK with it.</p>\n\n<p>update.sh: generate static site and upload to github.</p>\n\n<pre><code>#!/bin/bash\n\nBASE_DIR=`pwd`\nJ_DIR=&quot;./jekyll&quot;\nGIT_DIR=&quot;./wb14123.github.com&quot;\n\ncd $J_DIR\njekyll\ncd $BASE_DIR\nrm -r $GIT_DIR/*\ncp -r $J_DIR/_site/* $GIT_DIR/\ncd $GIT_DIR\ngit add -A .\ngit commit -m &quot;Changed at $(date)&quot;\ngit push origin master\nexit $?</code></pre>\n\n<p>newpost.sh: use vim to open a new post with current time and some meta information.</p>\n\n<pre><code>#!/bin/bash\n\nif [ $# -lt 1 ]\nthen\n    echo &quot;newpost: You need to specify the post name.&quot;\n    exit 1\nfi\n\nPOST_NAME=$1\nPOST_DATE=`date +%Y-%m-%d`\nPOST_DIR=&quot;./jekyll/_posts&quot;\nFILE_NAME=`echo &quot;$POST_DIR/$POST_DATE-$POST_NAME.md&quot; | sed &quot;s/ /-/g&quot;`\n\necho &quot;\n---\nlayout: post\ntitle: $POST_NAME\ncategories: misc\ntags: []\n---\n&quot; &gt; $FILE_NAME\n\nvim $FILE_NAME</code></pre>"}].push(blog);
        if (tags[blog] === undefined) {
          tags[blog] = 1;
        }
        tags[blog] +=  1;
      
        posts[{"layout"=>"post", "title"=>"Comment And Search Are Available", "categories"=>["workspace"], "tags"=>["blog", "disqus", "google"], "url"=>"/workspace/2012/11/20/Comment-And-Search-Are-Available.html", "date"=>2012-11-20 00:00:00 +0800, "id"=>"/workspace/2012/11/20/Comment-And-Search-Are-Available", "next"=><Post: /notes/2012/11/27/Compile-And-Install-Kernel>, "previous"=><Post: /workspace/2012/11/19/my-new-blog>, "content"=>"<p>As you can see, my blog are able to comment and search now!</p>\n\n<h2 id='comment'>Comment</h2>\n\n<p>I always think comment is very important for a blog. You can know how helpful or is there some issues in your article. <a href='http://disqus.com'>Disqus</a> is a great tool to put comment on a website. It is neat and powerful as you can see. It may be a little slow in China. But consider of my blog are mostly written in English, it is not a big deal.</p>\n\n<h2 id='search'>Search</h2>\n\n<p>The search engine I am using is <a href='http://www.google.com/cse'>Google custom search engine</a>. Isn&#8217;t it awesome I have google&#8217;s technology on my blog? It is easy to use, too. The badness of this choice is google may take some time to put the website&#8217;s content into its index. And google is even not available in China sometimes.</p>\n\n<h2 id='scripts_to_make_life_easy'>Scripts to Make Life Easy</h2>\n\n<p>As I put the website on <a href='http://pages.github.com/'>github page</a>, I don&#8217;t want to upload the jekyll directory. Just the static site is enough. So I must copy the site to git repository, add, commit and then push it. It is a boring work. I write two scripts to make it easy. I don&#8217;t know if there is some other way to do this, but I&#8217;m OK with it.</p>\n\n<p>update.sh: generate static site and upload to github.</p>\n\n<pre><code>#!/bin/bash\n\nBASE_DIR=`pwd`\nJ_DIR=&quot;./jekyll&quot;\nGIT_DIR=&quot;./wb14123.github.com&quot;\n\ncd $J_DIR\njekyll\ncd $BASE_DIR\nrm -r $GIT_DIR/*\ncp -r $J_DIR/_site/* $GIT_DIR/\ncd $GIT_DIR\ngit add -A .\ngit commit -m &quot;Changed at $(date)&quot;\ngit push origin master\nexit $?</code></pre>\n\n<p>newpost.sh: use vim to open a new post with current time and some meta information.</p>\n\n<pre><code>#!/bin/bash\n\nif [ $# -lt 1 ]\nthen\n    echo &quot;newpost: You need to specify the post name.&quot;\n    exit 1\nfi\n\nPOST_NAME=$1\nPOST_DATE=`date +%Y-%m-%d`\nPOST_DIR=&quot;./jekyll/_posts&quot;\nFILE_NAME=`echo &quot;$POST_DIR/$POST_DATE-$POST_NAME.md&quot; | sed &quot;s/ /-/g&quot;`\n\necho &quot;\n---\nlayout: post\ntitle: $POST_NAME\ncategories: misc\ntags: []\n---\n&quot; &gt; $FILE_NAME\n\nvim $FILE_NAME</code></pre>"}].push(disqus);
        if (tags[disqus] === undefined) {
          tags[disqus] = 1;
        }
        tags[disqus] +=  1;
      
        posts[{"layout"=>"post", "title"=>"Comment And Search Are Available", "categories"=>["workspace"], "tags"=>["blog", "disqus", "google"], "url"=>"/workspace/2012/11/20/Comment-And-Search-Are-Available.html", "date"=>2012-11-20 00:00:00 +0800, "id"=>"/workspace/2012/11/20/Comment-And-Search-Are-Available", "next"=><Post: /notes/2012/11/27/Compile-And-Install-Kernel>, "previous"=><Post: /workspace/2012/11/19/my-new-blog>, "content"=>"<p>As you can see, my blog are able to comment and search now!</p>\n\n<h2 id='comment'>Comment</h2>\n\n<p>I always think comment is very important for a blog. You can know how helpful or is there some issues in your article. <a href='http://disqus.com'>Disqus</a> is a great tool to put comment on a website. It is neat and powerful as you can see. It may be a little slow in China. But consider of my blog are mostly written in English, it is not a big deal.</p>\n\n<h2 id='search'>Search</h2>\n\n<p>The search engine I am using is <a href='http://www.google.com/cse'>Google custom search engine</a>. Isn&#8217;t it awesome I have google&#8217;s technology on my blog? It is easy to use, too. The badness of this choice is google may take some time to put the website&#8217;s content into its index. And google is even not available in China sometimes.</p>\n\n<h2 id='scripts_to_make_life_easy'>Scripts to Make Life Easy</h2>\n\n<p>As I put the website on <a href='http://pages.github.com/'>github page</a>, I don&#8217;t want to upload the jekyll directory. Just the static site is enough. So I must copy the site to git repository, add, commit and then push it. It is a boring work. I write two scripts to make it easy. I don&#8217;t know if there is some other way to do this, but I&#8217;m OK with it.</p>\n\n<p>update.sh: generate static site and upload to github.</p>\n\n<pre><code>#!/bin/bash\n\nBASE_DIR=`pwd`\nJ_DIR=&quot;./jekyll&quot;\nGIT_DIR=&quot;./wb14123.github.com&quot;\n\ncd $J_DIR\njekyll\ncd $BASE_DIR\nrm -r $GIT_DIR/*\ncp -r $J_DIR/_site/* $GIT_DIR/\ncd $GIT_DIR\ngit add -A .\ngit commit -m &quot;Changed at $(date)&quot;\ngit push origin master\nexit $?</code></pre>\n\n<p>newpost.sh: use vim to open a new post with current time and some meta information.</p>\n\n<pre><code>#!/bin/bash\n\nif [ $# -lt 1 ]\nthen\n    echo &quot;newpost: You need to specify the post name.&quot;\n    exit 1\nfi\n\nPOST_NAME=$1\nPOST_DATE=`date +%Y-%m-%d`\nPOST_DIR=&quot;./jekyll/_posts&quot;\nFILE_NAME=`echo &quot;$POST_DIR/$POST_DATE-$POST_NAME.md&quot; | sed &quot;s/ /-/g&quot;`\n\necho &quot;\n---\nlayout: post\ntitle: $POST_NAME\ncategories: misc\ntags: []\n---\n&quot; &gt; $FILE_NAME\n\nvim $FILE_NAME</code></pre>"}].push(google);
        if (tags[google] === undefined) {
          tags[google] = 1;
        }
        tags[google] +=  1;
      
    
      posts[{"title"=>"My New Blog Website", "layout"=>"post", "categories"=>["workspace"], "tags"=>["blog", "jekyll"], "url"=>"/workspace/2012/11/19/my-new-blog.html", "date"=>2012-11-19 00:00:00 +0800, "id"=>"/workspace/2012/11/19/my-new-blog", "next"=><Post: /workspace/2012/11/20/Comment-And-Search-Are-Available>, "previous"=>nil, "content"=>"<p>This is my new blog website, just as simple and as good as my imagine. It is powered by jekyll - a ruby tool to generate a static website. I am using wordpress writing a Chinese blog, too. But its editor is not good enough to write with. On the other hand, jekyll makes it possible to write with markdown, which is really a good tool for writing. Also, a static website is efficient and awesome.</p>\n\n<p>But this site is too simple now. There are some features I missed, such as search box, comment, archives by date, index by tags and so on. Some of them could be solved by third party, and some of them could be solved by plugins. But it makes the blog not so simple any more.</p>\n\n<p>With so many cool techs nowadays, it is easy to write a website. But it is not so easy to generate a static website with many features. Here is something about balance. They said &#8220;keep it stupid and simple&#8221;, and &#8220;less is more&#8221;. It is really an art to find out how less is just good for a production. Even the user himself doesn&#8217;t exactly know how much he wanted.</p>\n\n<p>Anyway, here is my new blog. Have fun and enjoy it!</p>"}] = [];
      
        posts[{"title"=>"My New Blog Website", "layout"=>"post", "categories"=>["workspace"], "tags"=>["blog", "jekyll"], "url"=>"/workspace/2012/11/19/my-new-blog.html", "date"=>2012-11-19 00:00:00 +0800, "id"=>"/workspace/2012/11/19/my-new-blog", "next"=><Post: /workspace/2012/11/20/Comment-And-Search-Are-Available>, "previous"=>nil, "content"=>"<p>This is my new blog website, just as simple and as good as my imagine. It is powered by jekyll - a ruby tool to generate a static website. I am using wordpress writing a Chinese blog, too. But its editor is not good enough to write with. On the other hand, jekyll makes it possible to write with markdown, which is really a good tool for writing. Also, a static website is efficient and awesome.</p>\n\n<p>But this site is too simple now. There are some features I missed, such as search box, comment, archives by date, index by tags and so on. Some of them could be solved by third party, and some of them could be solved by plugins. But it makes the blog not so simple any more.</p>\n\n<p>With so many cool techs nowadays, it is easy to write a website. But it is not so easy to generate a static website with many features. Here is something about balance. They said &#8220;keep it stupid and simple&#8221;, and &#8220;less is more&#8221;. It is really an art to find out how less is just good for a production. Even the user himself doesn&#8217;t exactly know how much he wanted.</p>\n\n<p>Anyway, here is my new blog. Have fun and enjoy it!</p>"}].push(blog);
        if (tags[blog] === undefined) {
          tags[blog] = 1;
        }
        tags[blog] +=  1;
      
        posts[{"title"=>"My New Blog Website", "layout"=>"post", "categories"=>["workspace"], "tags"=>["blog", "jekyll"], "url"=>"/workspace/2012/11/19/my-new-blog.html", "date"=>2012-11-19 00:00:00 +0800, "id"=>"/workspace/2012/11/19/my-new-blog", "next"=><Post: /workspace/2012/11/20/Comment-And-Search-Are-Available>, "previous"=>nil, "content"=>"<p>This is my new blog website, just as simple and as good as my imagine. It is powered by jekyll - a ruby tool to generate a static website. I am using wordpress writing a Chinese blog, too. But its editor is not good enough to write with. On the other hand, jekyll makes it possible to write with markdown, which is really a good tool for writing. Also, a static website is efficient and awesome.</p>\n\n<p>But this site is too simple now. There are some features I missed, such as search box, comment, archives by date, index by tags and so on. Some of them could be solved by third party, and some of them could be solved by plugins. But it makes the blog not so simple any more.</p>\n\n<p>With so many cool techs nowadays, it is easy to write a website. But it is not so easy to generate a static website with many features. Here is something about balance. They said &#8220;keep it stupid and simple&#8221;, and &#8220;less is more&#8221;. It is really an art to find out how less is just good for a production. Even the user himself doesn&#8217;t exactly know how much he wanted.</p>\n\n<p>Anyway, here is my new blog. Have fun and enjoy it!</p>"}].push(jekyll);
        if (tags[jekyll] === undefined) {
          tags[jekyll] = 1;
        }
        tags[jekyll] +=  1;
      
    
  }
</script>

    </section>

    <footer id="page_footer">
      Copyright @ 2012 Bin Wang
      <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="/static/images/cc.png" /></a><br />Licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.en_US">Creative Commons Attribution-NonCommercial-ShareAlike 3.0 China Mainland License</a>.
    </footer>
  </body>
</html>
